package protogenic

import (
	"bytes"
	"text/template"

	_ "embed"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	//go:embed templates/typescript/types.go.tmpl
	_types string
	//go:embed templates/typescript/enums.go.tmpl
	_enums string
)

type Field struct {
	Name      string
	JSONName  *string
	Type      string
	Optional  bool
	IsBuiltIn bool
	IsArray   bool
}

type Type struct {
	Name   string
	Fields []Field
	IsEnum bool
}

func getType(field *protogen.Field) (string, bool, bool) {
	isBuiltIn := true
	isArrayType := false
	buf := bytes.NewBufferString("")
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		buf.WriteString("boolean")
	case protoreflect.EnumKind:
		buf.WriteString(string(field.Enum.Desc.Name()))
	case protoreflect.BytesKind,
		protoreflect.FloatKind,
		protoreflect.DoubleKind,
		protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Sfixed64Kind:
		buf.WriteString("number")
	case protoreflect.StringKind:
		buf.WriteString("string")
	case protoreflect.MessageKind, protoreflect.GroupKind:
		{
			isBuiltIn = false
			messageKind := string(field.Message.Desc.Name())
			if messageKind == "Any" {
				buf.WriteString("any")
			} else {
				buf.WriteString(messageKind)
			}
		}
	}
	if field.Desc.IsList() {
		isArrayType = true
	}
	return buf.String(), isBuiltIn, isArrayType
}

func createEnum(enum *protogen.Enum) Type {

	e := Type{}
	e.Name = string(enum.Desc.Name())
	e.IsEnum = true
	e.Fields = make([]Field, 0)
	for _, value := range enum.Values {
		e.Fields = append(e.Fields, Field{string(value.Desc.Name()), nil, "", false, false, false})
	}
	return e
}
func createMessage(message *protogen.Message) []Type {
	types := make([]Type, 0)
	for _, _message := range message.Messages {
		types = append(types, createMessage(_message)...)
	}
	for _, enum := range message.Enums {
		types = append(types, createEnum(enum))
	}
	t := Type{}
	t.Name = string(message.Desc.Name())
	t.Fields = make([]Field, 0)
	for _, field := range message.Fields {
		if field.Oneof != nil {
			f := Field{}
			f.Name = string(field.Desc.Name())
			f.Optional = true
			_type, isBuiltIn, isArray := getType(field)
			f.Type = _type
			f.IsBuiltIn = isBuiltIn
			f.IsArray = isArray
			t.Fields = append(t.Fields, f)
			continue
		}
		f := Field{}
		f.Name = string(field.Desc.Name())
		jsonName := field.Desc.JSONName()
		if f.Name != jsonName {
			f.JSONName = &jsonName
		}
		f.Optional = isOptional(field)
		_type, isBuiltIn, isArray := getType(field)
		f.Type = _type
		f.IsBuiltIn = isBuiltIn
		f.IsArray = isArray
		t.Fields = append(t.Fields, f)
	}
	types = append(types, t)
	return types
}
func GenerateTypescript(plugin *protogen.Plugin, file *protogen.File) error {
	typesTemplates, err := template.New("types").Funcs(_funcs).Parse(_types)
	if err != nil {
		return err
	}
	enumsTemplate, err := template.New("enums").Funcs(_funcs).Parse(_enums)
	if err != nil {
		return err
	}
	filename := file.GeneratedFilenamePrefix + ".pb.ts"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protogenic. DO NOT EDIT.\r\n")
	g.P("/* tslint:disable */")
	for _, enum := range file.Enums {
		var enums bytes.Buffer
		err := enumsTemplate.Execute(&enums, createEnum(enum))
		if err != nil {
			return err
		}
		g.P(enums.String())
	}
	for _, message := range file.Messages {
		var types bytes.Buffer
		err := typesTemplates.Execute(&types, createMessage(message))
		if err != nil {
			return err
		}
		str := PostProcess(types)
		g.P(str.String())
	}
	return nil
}

func isOptional(field *protogen.Field) bool {
	return field.Desc.HasOptionalKeyword()
}
