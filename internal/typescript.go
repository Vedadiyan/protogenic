package protogenic

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"
	"text/template"

	_ "embed"

	rpc "github.com/vedadiyan/protogenic/internal/autogen"
	"github.com/vedadiyan/strcase"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

var (
	//go:embed templates/typescript/types.go.tmpl
	_types string
	//go:embed templates/typescript/enums.go.tmpl
	_enums string
	//go:embed templates/typescript/client.go.tmpl
	_client string
)

type Field struct {
	Name      string
	JSONName  *string
	Type      string
	Optional  bool
	IsBuiltIn bool
	IsArray   bool
}

type Type struct {
	Name   string
	Fields []Field
	IsEnum bool
}

type Client struct {
	Name         string
	RequestType  string
	ResponseType string
	Protected    bool
	Method       string
	URLParams    string
	QueryParams  string
	URL          string
}

func getType(field *protogen.Field) (string, bool, bool) {
	isBuiltIn := true
	isArrayType := false
	buf := bytes.NewBufferString("")
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		buf.WriteString("boolean")
	case protoreflect.EnumKind:
		buf.WriteString(string(field.Enum.Desc.Name()))
	case protoreflect.BytesKind,
		protoreflect.FloatKind,
		protoreflect.DoubleKind,
		protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Sfixed64Kind:
		buf.WriteString("number")
	case protoreflect.StringKind:
		buf.WriteString("string")
	case protoreflect.MessageKind, protoreflect.GroupKind:
		{
			isBuiltIn = false
			messageKind := string(field.Message.Desc.Name())
			if messageKind == "Any" {
				buf.WriteString("any")
			} else {
				buf.WriteString(messageKind)
			}
		}
	}
	if field.Desc.IsList() {
		isArrayType = true
	}
	return buf.String(), isBuiltIn, isArrayType
}

func createEnum(enum *protogen.Enum) Type {

	e := Type{}
	e.Name = string(enum.Desc.Name())
	e.IsEnum = true
	e.Fields = make([]Field, 0)
	for _, value := range enum.Values {
		e.Fields = append(e.Fields, Field{string(value.Desc.Name()), nil, "", false, false, false})
	}
	return e
}
func createMessage(message *protogen.Message) []Type {
	types := make([]Type, 0)
	for _, _message := range message.Messages {
		types = append(types, createMessage(_message)...)
	}
	for _, enum := range message.Enums {
		types = append(types, createEnum(enum))
	}
	t := Type{}
	t.Name = string(message.Desc.Name())
	t.Fields = make([]Field, 0)
	for _, field := range message.Fields {
		if field.Oneof != nil {
			f := Field{}
			f.Name = string(field.Desc.Name())
			f.Optional = true
			_type, isBuiltIn, isArray := getType(field)
			f.Type = _type
			f.IsBuiltIn = isBuiltIn
			f.IsArray = isArray
			t.Fields = append(t.Fields, f)
			continue
		}
		f := Field{}
		f.Name = string(field.Desc.Name())
		jsonName := field.Desc.JSONName()
		if f.Name != jsonName {
			f.JSONName = &jsonName
		}
		f.Optional = isOptional(field)
		_type, isBuiltIn, isArray := getType(field)
		f.Type = _type
		f.IsBuiltIn = isBuiltIn
		f.IsArray = isArray
		t.Fields = append(t.Fields, f)
	}
	types = append(types, t)
	return types
}
func GenerateTypescript(plugin *protogen.Plugin, file *protogen.File) error {
	typesTemplates, err := template.New("types").Funcs(_funcs).Parse(_types)
	if err != nil {
		return err
	}
	enumsTemplate, err := template.New("enums").Funcs(_funcs).Parse(_enums)
	if err != nil {
		return err
	}
	filename := file.GeneratedFilenamePrefix + ".pb.ts"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protogenic. DO NOT EDIT.\r\n")
	g.P("/* tslint:disable */")
	for _, enum := range file.Enums {
		var enums bytes.Buffer
		err := enumsTemplate.Execute(&enums, createEnum(enum))
		if err != nil {
			return err
		}
		g.P(enums.String())
	}
	for _, message := range file.Messages {
		var types bytes.Buffer
		err := typesTemplates.Execute(&types, createMessage(message))
		if err != nil {
			return err
		}
		str := PostProcess(types)
		g.P(str.String())
	}
	routeParamsPattern, err := regexp.Compile(`:(\w+)`)
	if err != nil {
		return err
	}
	queryParamsPattern, err := regexp.Compile(`\?.*`)
	if err != nil {
		return err
	}
	clientTemplate, err := template.New("client").Funcs(_funcs).Parse(_client)
	if err != nil {
		return err
	}
	for _, service := range file.Services {
		filename := file.GeneratedFilenamePrefix + fmt.Sprintf("_%s_gateway.pb.ts", service.GoName)
		serviceOptions := service.Desc.Options().(*descriptorpb.ServiceOptions)
		apiGateway := proto.GetExtension(serviceOptions, rpc.E_ApiGateway).(*rpc.APIGateway)
		routeParams := routeParamsPattern.FindAllString(apiGateway.Route, -1)
		queryParams := queryParamsPattern.FindAllString(apiGateway.Route, -1)
		urlParamList := make([]string, 0)
		queryParamList := make([]string, 0)
		route := apiGateway.Route
		for _, routeParam := range routeParams {
			_routeParam := strings.TrimPrefix(routeParam, ":")
			urlParamList = append(urlParamList, fmt.Sprintf(`'%s'`, _routeParam))
			route = strings.Replace(route, routeParam, fmt.Sprintf("${input.%s}", strcase.ToCamel(_routeParam)), 1)
		}
		if len(queryParams) > 0 {
			if len(queryParams) > 1 {
				return fmt.Errorf("ambiguous query string detected")
			}
			queryParams = strings.Split(queryParams[0], "&")
			for _, queryParam := range queryParams {
				queryParamList = append(queryParamList, fmt.Sprintf(`'%s'`, queryParam))
			}
		}
		params := strings.Join(urlParamList, ",")
		qParams := strings.Join(queryParamList, ",")
		clients := make([]Client, 0)
		for _, method := range service.Methods {
			client := Client{}
			client.URLParams = params
			client.Name = method.GoName
			client.Method = IfNill(apiGateway.Method, "GET")
			client.RequestType = method.Input.GoIdent.GoName
			client.ResponseType = method.Output.GoIdent.GoName
			client.QueryParams = qParams
			if apiGateway.Authenticated != nil {
				client.Protected = *apiGateway.Authenticated
			}
			client.URL = route
			clients = append(clients, client)
		}
		svc := plugin.NewGeneratedFile(strings.ToLower(filename), file.GoImportPath)
		var buffer bytes.Buffer
		err = clientTemplate.Execute(&buffer, struct {
			ServiceName string
			Clients     []Client
		}{ServiceName: service.GoName, Clients: clients})
		if err != nil {
			return err
		}
		svc.P(buffer.String())
	}
	return nil
}

func isOptional(field *protogen.Field) bool {
	return field.Desc.HasOptionalKeyword()
}
