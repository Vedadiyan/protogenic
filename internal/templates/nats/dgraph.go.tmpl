// Code generated by protogeinc. DO NOT EDIT.
// versions:
// 	protogenic 	  {{ .ProtogenicVersion }}
// 	protoc        {{ .CompilerVersion }}
// source: {{ .File }}
package {{ .ImportPath }}

import (
	"bytes"
	"context"
	"text/template"
    "crypto/sha256"
	"encoding/hex"

	{{- if gt .CacheInterval 0}}
	"time"
	{{- end }}
	"github.com/vedadiyan/goal/pkg/di"
	"github.com/vedadiyan/goal/pkg/service"
    "github.com/dgraph-io/dgo/v2"
	{{- if ne .Type "query"}} 
	"github.com/dgraph-io/dgo/v2/protos/api"
	{{- end }}
	{{- if eq .Type "query"}} 
    "google.golang.org/protobuf/encoding/protojson"
	{{- end }}
)

func init() {
	const (
        	DSN		= "{{ .Dsn }}"
		CN         	= "{{ .ConnName }}"
		NS         	= "{{ .Namespace }}"
		QUEUE      	= "{{ .Queue }}"
	)

	var (
		_query []byte
	)

	type (
		Request  = {{ .RequestType }}
		Response = {{ .ResponseType}}
	)

	_query = {{ .Query }}

    sha256 := sha256.New()
	_, err := sha256.Write(_query)
	if err != nil {
		panic(err)
	}
    hash := sha256.Sum(nil)
    
    template, err := template.New(hex.EncodeToString(hash)).Parse(string(_query))
	if err != nil {
		panic(err)
	}

	{{- if eq .Type "query"}} 
    unmarshaller := protojson.UnmarshalOptions{DiscardUnknown: true}
	{{- end }}

	handler := func(m *Request) (*Response, error) {
		client, err := di.ResolveWithName[dgo.Dgraph](DSN, nil)
		if err != nil {
			return nil, err
		}
		var buffer bytes.Buffer
		err = template.Execute(&buffer, m)
		if err != nil {
			return nil, err
		}
		{{- if eq .Type "set"}} 
		rs, err := client.NewTxn().Mutate(context.Background(), &api.Mutation{CommitNow: true, SetJson: buffer.Bytes()})
		if err != nil {
			return nil, err
		}
		response := Response{}
		if rs.Uids == nil {
			return &response, nil
		}
		ids := make([]string, 0)
		for _, value := range rs.Uids {
			ids = append(ids, value)
		}
		response.Uids = ids
		return &response, nil
		{{- else if eq .Type "delete"}} 
		_, err = client.NewTxn().Mutate(context.Background(), &api.Mutation{CommitNow: true, DeleteJson: buffer.Bytes()})
		if err != nil {
			return nil, err
		}
		response := Response{}
		return &response, nil
		{{- else }}
		rs, err := client.NewReadOnlyTxn().Query(context.Background(), buffer.String())
		if err != nil {
			return nil, err
		}
		var response Response
		err = unmarshaller.Unmarshal(rs.Json, &response)
		if err != nil {
			return nil, err
		}
		return &response, nil
		{{- end}}
	}

	service.Register(
		service.New(
			CN,
			NS,
			QUEUE,
			handler,
			{{- if gt .CacheInterval 0}}
			service.WithCache(time.Millisecond * {{ .CacheInterval }}),
			{{- end }}
			{{- if .Callback.OnSuccess }}
			service.WithOnSuccessCallBacks(
				{{- range $item :=  .Callback.OnSuccess }}
					"{{$item}}",
				{{- end }}
			),
			{{- end }}
			{{- if .Callback.OnError }}
			service.WithOnFailureCallBacks(
				{{- range $item :=  .Callback.OnError }}
					"{{$item}}",
				{{- end }}
			),
			{{- end }}
		),
	)
}
