// Code generated by protogeinc. DO NOT EDIT.
// versions:
// 	protogenic 	  {{ .ProtogenicVersion }}
// 	protoc        {{ .CompilerVersion }}
// source: {{ .File }}
package {{ .ImportPath }}

import (
	"time"

	helpers "github.com/vedadiyan/goal-helpers/pkg"
	"github.com/vedadiyan/goal/pkg/db/postgres"
	"github.com/vedadiyan/goal/pkg/service"
	{{- range $index, $value := .ExtraImports }}
	{{ $value }}
	{{- end }}
)

func init() {
	type (
		Request  = {{ .RequestType }}
		Response = {{ .ResponseType}}
	)

	const (
		DSN		 = "{{ .Dsn }}"
		CN       = "{{ .ConnName }}"
		NS       = "{{ .Namespace }}"
		QUEUE    = "{{ .Queue }}"
		TYPE     = {{ if eq .Type "command" }} postgres.COMMAND {{ else if eq .Type "query" }} postgres.QUERY {{ end }}
	)

	var (
		reqMapper []byte
		resMapper []byte
		sql       []byte
	)

	reqMapper = {{ .RequestMapper }}
	resMapper = {{ .ResponseMapper }}
	sql = {{ .Sql }}
	
	handler :=func(m *Request) (*Response, error) {
		arguments, err := helpers.ExecToMap(m, reqMapper)
		if err != nil {
			return nil, err
		}
		res, err := postgres.Handle(DSN, TYPE, string(sql), arguments)
		if err != nil {
			return nil, err
		}
		var response Response
		err = helpers.ExecFromMap(map[string]any {"data": res}, resMapper, &response)
		if err != nil {
			return nil, err
		}
		return &response, nil
	}
	
	service.Register(
		service.New(
			CN,
			NS,
			QUEUE,
			handler,
			{{- if gt .CacheInterval 0}}
			service.WithCache(time.Millisecond * {{ .CacheInterval }}),
			{{- end }}
			{{- if .Callback.OnSuccess }}
			service.WithOnSuccessCallBacks(
				{{- range $item :=  .Callback.OnSuccess }}
					"{{$item}}",
				{{- end }}
			),
			{{- end }}
			{{- if .Callback.OnError }}
			service.WithOnFailureCallBacks(
				{{- range $item :=  .Callback.OnError }}
					"{{$item}}",
				{{- end }}
			),
			{{- end }}
		),
	)
}